import Gzip
import UIKit

/// Electronic Health Certificate Validation Core
///
/// This struct provides an interface for validating EHN Health certificates generated by https://dev.a-sit.at/certservice
public struct ValidationCore {
    private let PREFIX = "HC1:"
    private let CERT_SERVICE_URL = "https://dgc.a-sit.at/ehn/"
    private let CERT_PATH = "cert/"

    
    private var completionHandler : ((Result<ValidationResult, ValidationError>) -> ())?
    private var scanner : QrCodeScanner?
    
    public init(){}

    
    //MARK: - Public API
    
    /// Instantiate a QR code scanner and validate the scannned EHN health certificate
    public mutating func validateQrCode(_ vc : UIViewController, prompt: String = "Scan QR Code", _ completionHandler: @escaping (Result<ValidationResult, ValidationError>) -> ()){
        self.completionHandler = completionHandler
        self.scanner = QrCodeScanner()
        scanner?.scan(vc, prompt, self)
    }
    
    /// Validate an Base45-encoded EHN health certificate
    public func validate(encodedData: String, _ completionHandler: @escaping (Result<ValidationResult, ValidationError>) -> ()) {
        guard let unprefixedEncodedString = removeScheme(prefix: PREFIX, from: encodedData) else {
            completionHandler(.failure(.INVALID_SCHEME_PREFIX))
            return
        }
        
        guard let decodedData = decode(unprefixedEncodedString) else {
            completionHandler(.failure(.BASE_45_DECODING_FAILED))
            return
        }
        
        guard let decompressedData = decompress(decodedData) else {
            completionHandler(.failure(.DECOMPRESSION_FAILED))
            return
        }

        guard let cose = cose(from: decompressedData) else {
            completionHandler(.failure(.COSE_DESERIALIZATION_FAILED))
            return
        }
        retrieveSignatureCertificate(with: cose.keyId) { cert in
            completionHandler(.success(ValidationResult(isValid: cose.hasValidSignature(for: cert), payload: cose.payload.euHealthCert)))
        }
    }
    

    //MARK: - Helper Functions
    
    /// Retrieves the signature certificate for a given keyId
    private func retrieveSignatureCertificate(with keyId: String?, _ completionHandler: @escaping (String?)->()) {
        guard let keyId = keyId,
              let url = URL(string: "\(CERT_SERVICE_URL)\(CERT_PATH)\(keyId)") else {
            return
        }

        var request = URLRequest(url: url)
        request.addValue("text/plain", forHTTPHeaderField: "Accept")
        URLSession.shared.dataTask(with: request) { body, response, error in
            guard error == nil,
                  let status = (response as? HTTPURLResponse)?.statusCode,
                  200 == status,
                  let body = body else {
                completionHandler(nil)
                return
            }
            let encodedCert = String(data: body, encoding: .utf8)
            completionHandler(encodedCert)
        }.resume()
    }
    
    /// Strips a given scheme prefix from the encoded EHN health certificate
    private func removeScheme(prefix: String, from encodedString: String) -> String? {
        guard encodedString.starts(with: prefix) else {
            return nil
        }
        return String(encodedString.dropFirst(prefix.count))
    }
    
    /// Base45-decodes an EHN health certificate
    private func decode(_ encodedData: String) -> Data? {
        return try? encodedData.fromBase45()
    }
    
    /// Decompress the EHN health certificate using ZLib
    private func decompress(_ encodedData: Data) -> Data? {
        return try? encodedData.gunzipped()
    }

    /// Creates COSE structure from EHN health certificate
    private func cose(from data: Data) -> Cose? {
       return Cose(from: data)
    }
    
}

// MARK: - QrCodeReceiver

extension ValidationCore : QrCodeReceiver {
    public func canceled() {
        completionHandler?(.failure(.USER_CANCELLED))
    }
    
    /// Process the scanned EHN health certificate
    public func onQrCodeResult(_ result: String?) {
        guard let result = result,
              let completionHandler = self.completionHandler else {
            self.completionHandler?(.failure(.QR_CODE_ERROR))
            return
        }
        validate(encodedData: result, completionHandler)
    }
}

//
//  Base45.swift
//  Base45-Swift
//
//  Created by Dirk-Willem van Gulik on 01/04/2021.
//

import Foundation

extension String {
    enum Base45Error: Error {
        case Base64InvalidCharacter
        case Base64InvalidLength
    }
    
    public func fromBase45() throws ->Data  {
        let BASE45_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:"
        var d = Data()
        var o = Data()
        
        for c in self.uppercased() {
            if let at = BASE45_CHARSET.firstIndex(of: c) {
                let idx  = BASE45_CHARSET.distance(from: BASE45_CHARSET.startIndex, to: at)
                d.append(UInt8(idx))
            } else {
                throw Base45Error.Base64InvalidCharacter
            }
        }
        for i in stride(from:0, to:d.count, by: 3) {
            if (d.count - i < 2) {
                throw Base45Error.Base64InvalidLength
            }
            var x : UInt32 = UInt32(d[i]) + UInt32(d[i+1])*45
            if (d.count - i >= 3) {
                x += 45 * 45 * UInt32(d[i+2])
                if (x >= 256*256) {
                   throw Base45Error.Base64InvalidCharacter
                }
                o.append(UInt8(x / 256))
            }
            o.append(UInt8(x % 256))
        }
        return o
    }
}

extension String {
    subscript(i: Int) -> String {
        return String(self[index(startIndex, offsetBy: i)])
    }
}

extension Data {
    public func toBase45()->String {
        let BASE45_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:"
        var o = String()
        for i in stride(from:0, to:self.count, by: 2) {
            if (self.count - i > 1) {
                let x : Int = (Int(self[i])<<8) + Int(self[i+1])
                let e : Int = x / (45*45)
                let x2 : Int = x % (45*45)
                let d : Int = x2 / 45
                let c : Int = x2 % 45
                o.append(BASE45_CHARSET[c])
                o.append(BASE45_CHARSET[d])
                o.append(BASE45_CHARSET[e])
            } else {
                let x2 : Int = Int(self[i])
                let d : Int = x2 / 45
                let c : Int = x2 % 45
                o.append(BASE45_CHARSET[c])
                o.append(BASE45_CHARSET[d])
            }
        }
        return o
    }
}
